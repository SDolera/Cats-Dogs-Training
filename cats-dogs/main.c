/******************************************************************************
 *
 * Copyright (C) 2022-2023 Maxim Integrated Products, Inc. All Rights Reserved.
 * (now owned by Analog Devices, Inc.),
 * Copyright (C) 2023 Analog Devices, Inc. All Rights Reserved. This software
 * is proprietary to Analog Devices, Inc. and its licensors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

// cats-dogs
// This file was @generated by ai8xize.py --test-dir sdk/Examples/MAX78000/CNN --prefix cats-dogs --checkpoint-file trained/ai85-catsdogs-qat8-q.pth.tar --config-file networks/cats-dogs-hwc.yaml --fifo --softmax --device MAX78000 --timer 0 --display-checkpoint --verbose --overwrite

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "mxc.h"
#include "cnn.h"
#include "sampledata.h"
#include "sampleoutput.h"

// Other includes
#include "mxc_device.h"
#include "mxc_sys.h"
#include "fcr_regs.h"
#include "icc.h"
#include "led.h"
#include "tmr.h"
#include "dma.h"
#include "pb.h"
#include "weights.h"
#include "sampledata.h"
#include "mxc_delay.h"
#include "camera.h"

//define for image, camera, and ascii art
#define ASCII_ART
#define IMAGE_SIZE_X (64 * 2)
#define IMAGE_SIZE_Y (64 * 2)

#define CAMERA_FREQ (5 * 1000 * 1000)

//RGB565 BUFFER FOR TFT
uint8_t data565[IMAGE_SIZE_X * 2];

//Classification layer
static int32_t ml_data[CNN_NUM_OUTPUTS];
static q15_t ml_softmax[CNN_NUM_OUTPUTS];

//stopwatch
volatile uint32_t cnn_time;

//get data.
#ifdef USE_SAMPLEDATA
// Data input: HWC 3x128x128 (49152 bytes total / 16384 bytes per channel);
static const uint32_t input_0[] = SAMPLE_INPUT_0;
#else
static uint32_t input_0[IMAGE_SIZE_X * IMAGE_SIZE_Y];//buffer for camera image
#endif

#ifdef ASCII_ART
char *brightness = "@%#*+=-:.";//simple
#define RATIO 2 // RATIO OF SCALING DOWN THE IMAGE TO DISPLAY IN ASCII

void asciiart(uint8_t *img)
{
    int skip_x, skip_y;
    uint8_t r, g, b, Y;
    uint8_t *srcPtr = img;
    int l = strlen(brightness) - 1;

    skip_x = RATIO;
    skip_y = RATIO;

    for (int i = 0; i < IMAGE_SIZE_Y; i++) {
        for (int j = 0; j < IMAGE_SIZE_X; j++) {
            r = *srcPtr++ ^ 0x80;
            g = *(srcPtr++) ^ 0x80;
            b = *(srcPtr++) ^ 0x80;

            srcPtr++; //skip msb=0x00

            //Y= 0.2126*r+ 0.7152*g+ 0.0722*b;
            Y = (3 * r + b + 4 * g) >> 3; // simple luminance conversion
            if ((skip_x == RATIO) && (skip_y == RATIO))
                printf("%c", brightness[l - (Y * l / 255)]);

            skip_x++;
            if (skip_x > RATIO)
                skip_x = 1;
        }
        skip_y++;

        if (skip_y > RATIO) {
            printf("\n");
            skip_y = 1;
        }

    }
}
#endif


void fail(void)
{
    printf("\n*** FAIL ***\n\n");
    while (1)
        ;
}

// Data input: HWC 3x128x128 (49152 bytes total / 16384 bytes per channel):
//static const uint32_t input_0[] = SAMPLE_INPUT_0;
void load_input(void)
{
    // This function loads the sample data input -- replace with actual data

    int i;
    const uint32_t *in0 = input_0;

    for (i = 0; i < 16384; i++) {
        // Remove the following line if there is no risk that the source would overrun the FIFO:
        while (((*((volatile uint32_t *)0x50000004) & 1)) != 0); // Wait for FIFO 0
        *((volatile uint32_t *)0x50000008) = *in0++; // Write FIFO 0
    }
}

void capture_process_camera(void) {
    uint8_t *raw;
    uint32_t imgLen;
    uint32_t w, h;

    int cnt = 0;

    uint8_t r, g, b;
    uint16_t rgb;
    int j = 0;

    uint8_t *data = NULL;
    stream_stat_t *stat;

    camera_start_capture_image();

    // Get the details of the image from the camera driver.
    camera_get_image(&raw, &imgLen, &w, &h);
    printf("W:%dH:%dL:%d\n", w, h, imgLen);

    // Get image line by line
    for(int row = 0; row < h; row++) {
        // Wait until camera streaming buffer is full
        while ((data = get_camera_stream_buffer()) == NULL) {
            if (camera_is_image_rcv()) {
                break;
            }
        }
        //LED_Toggle(LED2);
        j = 0;

        for(int k = 0; k < 4 * w; k += 4) {
            // data format:0x00bbggrr
            r = data[k];
            g = data[k + 1];
            b = data[k + 2];
            //skipk+3

            // change the range from [0,255] to [-128,127] and store in buffer for CNN
            input_0[cnt++] = ((b << 16) | (g << 8) | r) ^ 0x00808080;
            // convert to RGB656 for display
            rgb = ((r & 0b11111000) << 8) | ((g & 0b11111100) << 3) | (b >> 3);
            data565[j] = (rgb >> 8) & 0xFF;
            data565[j + 1] = rgb & 0xFF;
            j += 2;
        }

        //LED_Toggle(LED2);
        // Release stream buffer
        release_camera_stream_buffer();
    }

    //camera_sleep(1);
    stat = get_camera_stream_statistic();

    if (stat->overflow_count > 0) {
        printf("OVERFLOW DISP=%d\n", stat->overflow_count);
        LED_On(LED2);
        while(1){}
    }
}
//********************************************************************************************8 */
// Expected output of layer 6 for cats-dogs given the sample input (known-answer test)
// Delete this function for production code
//static const uint32_t sample_output[] = SAMPLE_OUTPUT;
//int check_output(void)
//{
//    int i;
//    uint32_t mask, len;
//    volatile uint32_t *addr;
//    const uint32_t *ptr = sample_output;
//
//    while ((addr = (volatile uint32_t *)*ptr++) != 0) {
//        mask = *ptr++;
//        len = *ptr++;
//        for (i = 0; i < len; i++)
//            if ((*addr++ & mask) != *ptr++) {
//                printf("Data mismatch (%d/%d) at address 0x%08x: Expected 0x%08x, read 0x%08x.\n",
//                       i + 1, len, addr - 1, *(ptr - 1), *(addr - 1) & mask);
//                return CNN_FAIL;
//            }
//    }
//
//    return CNN_OK;
//}


void softmax_layer(void)
{
    cnn_unload((uint32_t *)ml_data);
    softmax_q17p14_q15((const q31_t *)ml_data, CNN_NUM_OUTPUTS, ml_softmax);
}

int main(void)
{
    int i;
    int digs, tens;
    int ret = 0;
    int result[CNN_NUM_OUTPUTS];
    int dma_channel;

    const char classes[CNN_NUM_OUTPUTS][20] = { "Cat", "Dog" };

    #if defined(BOARD_FTHR_REVA)
        MXC_Delay(200000);
        Camera_Power(POWER_ON);
        printf("\n\nCats-vs-Dogs Feather Demo\n");
    #endif

    MXC_ICC_Enable(MXC_ICC0); // Enable cache

    // Switch to 100 MHz clock
    MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
    SystemCoreClockUpdate();

    printf("Waiting...\n");

    // DO NOT DELETE THIS LINE:
    MXC_Delay(SEC(2)); // Let debugger interrupt if needed

    // Enable peripheral, enable CNN interrupt, turn on CNN clock
    // CNN clock: APB (50 MHz) div 1
    cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK, MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);

    printf("\n*** CNN Inference Test cats-dogs ***\n");

    cnn_init(); // Bring state machine into consistent state
    cnn_load_weights(); // Load kernels
    cnn_load_bias();
    cnn_configure(); // Configure state machine
    //cnn_start(); // Start CNN processing
    //load_input(); // Load data input via FIFO

    //for camera init
    //init DMA for camera interface
    MXC_DMA_Init();
    dma_channel = MXC_DMA_AcquireChannel();

    printf("Init Camera.\n");
    camera_init(CAMERA_FREQ);

    ret = camera_setup(IMAGE_SIZE_X, IMAGE_SIZE_Y, PIXFORMAT_RGB888, FIFO_THREE_BYTE, STREAMING_DMA, dma_channel);

    if (ret != STATUS_OK) {
        printf("Error returned from setting up camera. Error %d \n", ret);
        return -1;
    }
    camera_write_reg(0x11, 0x0);

    printf("********** Press PB1(SW1) to capture an image. *********\r\n");
    while(!PB_Get(0)){}

    MXC_SYS_ClockEnable(MXC_SYS_PERIPH_CLOCK_CNN);

    while(1) {
        LED_Off(LED1);
        LED_Off(LED2);
    
        capture_process_camera();
        cnn_start();
        load_input();

    //while(cnn_time == 0)
    //MXC_LP_EnterSleepMode();
    SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
//************************************************************************* */
    while (cnn_time == 0) { // Wait for CNN interrupt
        __WFI();
    } 

    //if (check_output() != CNN_OK)
        //fail();
    softmax_layer();

    printf("\n*** PASS ***\n\n");
//************************************************************************ */
#ifdef CNN_INFERENCE_TIMER
    printf("Approximate data loading and inference time: %u us\n\n", cnn_time);
#endif

    cnn_disable(); // Shut down CNN clock, disable peripheral

    printf("Classification results:\n");
    for (i = 0; i < CNN_NUM_OUTPUTS; i++) {
        digs = (1000 * ml_softmax[i] + 0x4000) >> 15;
        tens = digs % 10;
        digs = digs / 10;
        printf("[%7d] -> %20s: %d.%d%%\r\n", ml_data[i], i, digs, tens);
    }

    printf("\n");

#ifdef ASCII_ART
    asciiart((uint8_t *)input_0);
    printf("********** Press PB1(SW1) to capture an image **********\r\n");
    
#endif
    while(!PB_Get(0)) {}
//while end
    }
    return 0;
}

/*
  SUMMARY OF OPS
  Hardware: 51,368,960 ops (50,432,000 macc; 936,960 comp; 0 add; 0 mul; 0 bitwise)
    Layer 0: 7,340,032 ops (7,077,888 macc; 262,144 comp; 0 add; 0 mul; 0 bitwise)
    Layer 1: 19,267,584 ops (18,874,368 macc; 393,216 comp; 0 add; 0 mul; 0 bitwise)
    Layer 2: 19,070,976 ops (18,874,368 macc; 196,608 comp; 0 add; 0 mul; 0 bitwise)
    Layer 3: 4,792,320 ops (4,718,592 macc; 73,728 comp; 0 add; 0 mul; 0 bitwise)
    Layer 4: 600,064 ops (589,824 macc; 10,240 comp; 0 add; 0 mul; 0 bitwise)
    Layer 5: 295,936 ops (294,912 macc; 1,024 comp; 0 add; 0 mul; 0 bitwise)
    Layer 6: 2,048 ops (2,048 macc; 0 comp; 0 add; 0 mul; 0 bitwise)

  RESOURCE USAGE
  Weight memory: 57,776 bytes out of 442,368 bytes total (13.1%)
  Bias memory:   2 bytes out of 2,048 bytes total (0.1%)
*/
